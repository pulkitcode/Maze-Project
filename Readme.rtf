 A University Project where the coordinates of walls, entry, exit points were given and we had to find the shortest path from entry to exit. This project was divided into four tasks.\
Task 1 : Your first task is to write a function build_cave(data) that builds a two-dimensional representation of a cave from a data dictionary specifying the features of that cave as described on the slide before. The function takes a single argument data, a dictionary of features in the cave, and returns a representation of the cave as a two-dimensional array (ie, a list of lists), or None if the dictionary of features specifies a non-valid cave, according to the rules on the previous slide. data = \{'size': 4,'entrance': (0, 0),'exit': (2, 1),'dragon': (0, 2),'sword': (3, 3),'treasure': [(1, 3)],'walls': [(1, 1), (1, 2), (2, 2), (2, 3)]\}\
Task 2 : You need to implement a function check_path(data, path) that takes two arguments data, a dictionary of features in the cave, as per Question 1, and a list of moves path constituting a path through the dungeon. Your function should return True if the path is valid, or False if it is not valid. You may assume that the cave specification is valid (ie, build_cave(data) will not return None). However, it is possible that even a valid cave specification will have no valid path through it; for example, if the exit is completely separated from the entrance by walls. When there is no possible valid path through the cave, check_path will return False for any path. data = \{'size': 4,'entrance': (0, 0),'exit': (2, 1),'dragon': (0, 2),'sword': (3, 3),'treasure': [(1, 3)],'walls': [(1, 1), (1, 2), (2, 2), (2, 3)]\} path = (['S'] * 3 + ['E'] * 3 + ['W'] * 3 + ['N'] * 3 + ['E'] * 3 + ['S'] + ['N'] + ['W'] * 3 + ['S', 'S', 'E'])\
Task 3: Write a function shortest_path(data, start, end, has_sword) that determines the length of the shortest valid path between two locations in a cave. The function takes four arguments data a dictionary of features in the cave, as per question 1; start a start location (as a tuple); end an end location (as a tuple); and has_sword a boolean indicating whether Falca currently holds the sword (as this may affect the choice of path). Your function should return the length of the shortest path between start and end. For simplicity, you should assume that the value of has_sword does not change while the shortest path is determined. That is, Falca cannot pick up the sword; If shortest_path is called with the argument False for has_sword, it will remain False, even if Falca happens to enter a location containing the sword.\
data = \{'size': 4,'entrance': (0, 0),'exit': (2, 1),'dragon': (0, 2),'sword': (3, 3),'treasure': [(1, 3)],'walls': [(1, 1), (1, 2), (2, 2), (2, 3)]\}\
\pard\pardeftab720\sl360\partightenfactor0
\cf2 Task 4: You need to implement a function optimal_path(data) that takes a single argument data, a dictionary of features in the cave, as per Question 1. Your function should return the length of the shortest path that enables Falca to collect all of the treasures and exit from the dungeon. data = \{'size': 4,'entrance': (0, 0),'exit': (2, 1),'dragon': (0, 2),'sword': (3, 3),'treasure': [(1, 3)],'walls': [(1, 1), (1, 2), (2, 2), (2, 3)]\}\
}
